from pyo import*

class Synth:

    audioServer = Server() # the audio server this synth will use

    allNoteFreqs = {} # once initialized, this holds note names as keys and their freqeuncies as values.
    # Each entry will look like these examples: {"A4" : 440}, {"D#5" : 622.25},  {"Eb5" : 622.25}
    # NOTE: Enharmonically equivalent notes are given seperate entries with identical values
    # All frequencies are given in equal temperment.

    allNoteNames = [] # once initialized, this holds a list of all note names. 
    # NOTE: the enharmonically equivalent notes are listed as *one* entry with a slash, e.g. "D#5/Eb5"

    # Below are step patterns for some different types of keys and modes
    # They're given as integer number of semitones above the previous frequency, starting at the tonic
    minorPent = [3,2,2,3,2]
    majorPent = [2,2,3,2,3]

    def __init__(self, noteFreqFile = "NoteFreqsCleaned.txt", noteNameFile = "NoteNames.txt"):
        """ Sets up the class allNoteFreqs dictionary and the allNoteNames list, and boots the audio server
        """
        with open(noteFreqFile,'r') as f:
            for line in f:
                tokens = line.split()
                self.allNoteFreqs[tokens[0]] = float(tokens[1])

        with open(noteNameFile,'r') as f:
            for line in f:
                self.allNoteNames.append(line.strip())
        

        print(self.allNoteNames)
        print(self.allNoteFreqs)
        self.audioServer.boot()

    def interpretData1(self, automataData, scale):
        """ Takes data generated by automata and returns a corresponding chord progression.

        Activtion rule: if the majority of the cells in a note's territory are active, the note will sound

        Param:
        ------
        automataData : list of list of ints
            A list containing lists of integers each representing the activation of cellular automata at a given time step
        scale : list of Strings
            A list containing string names of each note in some key 

        Return:
        -------
        progression : list of lists of strings
            A list of lists containing the names of each note to be played in a given step
        """
        dataWidth = len(automataData[0])
        scaleWidth = len(scale)

        assert(dataWidth >= scaleWidth), "Scale too large for data; please try again with smaller scale size"
        assert(dataWidth % scaleWidth == 0), "dataWidth must be evenly divisible by scaleWidth"

        noteWidth = dataWidth/scaleWidth # How many adjacent automata cells should be mapped to the activation of a single note

        progression = [[] for _ in range(len(automataData))]

        for chordData in range(len(automataData)):
            for i in range(0,int(dataWidth),int(noteWidth)):
                # for each note, this checks if the majority of its cells are ativated. If so, it plays the note.
                noteSum = 0
                for j in range(int(noteWidth)):
                    if automataData[chordData][i+j]:
                        noteSum += 1
                if noteSum >= noteWidth/2.0:
                    progression[chordData].append(scale[int(i/noteWidth)]) # add this note to the current chord

        return progression

    def playTune(self,chords,bpm):
        """Given a list of list of note names, plays them in sequence as quarter notes at the given BPM
        
        Param:
        ------
        chords : list of lists of strings
            The chords to be played and order to play them
        bpm:
            The tempo at which to play back the given tune
        """
        self.audioServer.start()
        for chord in chords:
            chordFreqs = self.getFreqs(chord)
            self.playNotes(chordFreqs, 60/bpm)
        self.audioServer.stop()


    def playNotes(self,noteFreqs, duration):
        """ Sounds a given set of frequencies for the given duration

        If passed an empty list, simply rests for duration

        Param:
        ------
        noteFreqs : list of floats
            List containing frequencies to be sounded
        duration : float
            How long to sound these frequencies
        """
        if noteFreqs: #if the list isn't empty
            chord = SuperSaw(noteFreqs).out()
        time.sleep(duration)

    def getScale(self, lowestTonic, numOctaves, scaleSteps):
        """ 
        Generates a list of all notes in a particular key given a particular tonic and number of octaves
        
        For example getNotesForKey("A4", 2, [3,2,2,3,2]) returns ['A4', 'C5', 'D5', 'E5', 'G5', 'A5', 'C6', 'D6', 'E6', 'G6']

        Param: 
        ------
        lowestTonic : String
            The lowest note (and tonic) to be included in the key. For example "A4", "Eb3", "C#2"

        numOctaves : int
            The number of octaves of the key that should be included

        scaleSteps : List of ints
            A list containing integer number of semitones above the previous frequency, starting at the tonic

        Return:
        -------
            A list of Strings representing the notes in a given key
        """
        lowestTonic = lowestTonic.capitalize().strip()

        # increment start index until we find the correct starting spot for our scals
        startIdx = -1
        lookingForStartIdx = True
        while lookingForStartIdx:
            startIdx += 1
            if lowestTonic in self.allNoteNames[startIdx]:
                lookingForStartIdx = False


        currIdx = startIdx
        notesInKey = []

        for oct in range(numOctaves):
            for step in scaleSteps:
                notesInKey.append(self.allNoteNames[currIdx])
                currIdx+=step
        
        return notesInKey
        
    def getFreqs(self, noteNames):
        """ Given a list of note names, returns a list holding the frequncies for each note

        Param:
        ------
        noteNames : list of strings
            The notes for which to retrieve frequencies
        
        Return:
        -------
            List of floats representing note frequencies
        """
        freqs = []

        for n in noteNames:
            freqs.append(self.allNoteFreqs[n])

        return freqs

    def getAllNoteFreqs(self):
        """ Returns internal dictionary between note names and their equal tempered frequency"""
        return self.allNoteFreqs
    
    def stopAudioLoop(self):
        self.audioServer.stop()

if __name__ == "__main__":
    synth = Synth()
    amPent = synth.getScale("A3",3, synth.minorPent)


    exampleTune = [[amPent[i] for i in [0,1,3]],
                   [amPent[i] for i in [1,3,4]],
                   [amPent[i] for i in [2,5,7]],
                   [amPent[i] for i in [3,4,8]],
                   [amPent[i] for i in [0,1,3]]]
    
    synth.playTune(exampleTune,60)


    # notes = [440, 659.25]

    # while notes[-1] < 1000:
    #     chord = SuperSaw(notes).out()
    #     newNotes = []
    #     for n in notes:
    #         newNotes.append(1.05946*n)
    #     notes = newNotes
    #     time.sleep(1)

    # 

